// Code generated by template.test. DO NOT EDIT.
// template.test 1.2.3

package widgets

import (
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/url"

	"github.com/jasonhancock/go-backoff"
	"github.com/ns-jsattler/go-httpc"
)

var nonRetryStatuses = httpc.StatusNotIn(
	http.StatusUnauthorized,
	http.StatusForbidden,
	http.StatusUnprocessableEntity,
	http.StatusBadRequest,
)

type Client struct {
	client *httpc.Client
}

type Iface interface {
	WidgetsList(ctx context.Context, param2 string, qp WidgetsListParams) error
}

// New creates a new client that will communicate with the server over HTTP.
func New(host url.URL, client httpc.Doer, b backoff.Backoffer) *Client {
	return &Client{
		client: httpc.New(
			client,
			httpc.WithBaseURL(host.String()),
			httpc.WithBackoff(b),
			httpc.WithRetryResponseErrors(),
		),
	}
}

// WidgetsList Gets a list of all widgets
func (c *Client) WidgetsList(ctx context.Context, param2 string, qp WidgetsListParams) error {
	err := c.client.GET("/v1/widgets").
		QueryParams(qp.get()...).
		Headers(qp.getHeaders()...).
		Success(httpc.StatusIn(http.StatusNoContent)).
		RetryStatus(nonRetryStatuses).
		NotFound(httpc.StatusIn(http.StatusNotFound)).
		Do(ctx)

	return err
}

func errorHandler(errMap map[int]error) httpc.ErrorFn {
	return func(r io.Reader, status int) error {
		if data, ok := errMap[status]; ok {
			dec := json.NewDecoder(r)
			if err := dec.Decode(data); err != nil {
				// the server returned a response body we cannot read. Ensure we read the
				// entire response body so the httpc error handling can pick it up, then
				// return nil.
				_, _ = io.Copy(io.Discard, r)
				return nil
			}
			return data
		}

		// In order for the plumbing to work to capture the resp body in the httpc
		// error handling, we need to read the body.
		_, _ = io.Copy(io.Discard, r)
		// by returning nil here, we should fall through to the default handling and
		// send a ClientErr
		return nil
	}
}
