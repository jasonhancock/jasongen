// Code generated by template.test. DO NOT EDIT.
// template.test 1.2.3

package widgets

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"

	"github.com/jasonhancock/go-backoff"
	"github.com/ns-jsattler/go-httpc"
	httpcerrors "github.com/ns-jsattler/go-httpc/errors"
)

var nonRetryStatuses = httpc.StatusNotIn(
	http.StatusUnauthorized,
	http.StatusForbidden,
	http.StatusUnprocessableEntity,
	http.StatusBadRequest,
)

type Client struct {
	client *httpc.Client
}

type Iface interface {
	Metrics(ctx context.Context) ([]byte, error)
	WidgetCreate(ctx context.Context, req WidgetCreateRequest) (Widget, error)
	WidgetDelete(ctx context.Context, id string) error
	WidgetDownload(ctx context.Context, id string) (*http.Response, error)
	WidgetGet(ctx context.Context, id string, num int64) (Widget, error)
	WidgetsList(ctx context.Context, qp WidgetsListParams) (WidgetsListResponse, error)
	WidgetsListStar(ctx context.Context, qp1 string) (WidgetsListResponse, error)
}

// New creates a new client that will communicate with the server over HTTP.
func New(host url.URL, client httpc.Doer, b backoff.Backoffer) *Client {
	return &Client{
		client: httpc.New(
			client,
			httpc.WithBaseURL(host.String()),
			httpc.WithBackoff(b),
			httpc.WithRetryResponseErrors(),
		),
	}
}

// Metrics Returns application metrics in a format Prometheus can scrape
func (c *Client) Metrics(ctx context.Context) ([]byte, error) {
	errorMap := map[int]error{
		http.StatusInternalServerError: &ErrorResponse{},
	}

	var data []byte
	err := c.client.GET("/metrics").
		Success(httpc.StatusIn(http.StatusOK)).
		RetryStatus(nonRetryStatuses).
		NotFound(httpc.StatusIn(http.StatusNotFound)).
		Decode(func(r io.Reader) error {
			var err error
			data, err = io.ReadAll(r)
			return err
		}).
		Header("Accept", "text/plain").
		OnError(errorHandler(errorMap)).
		Do(ctx)

	if cErr := errors.Unwrap(err); cErr != nil && cErr != httpcerrors.ErrUnexpectedResponse {
		err = cErr
	}

	return data, err
}

// WidgetCreate
func (c *Client) WidgetCreate(ctx context.Context, req WidgetCreateRequest) (Widget, error) {
	var data Widget
	err := c.client.POST("/v1/widgets").
		ContentType("application/json").
		Body(req).
		Success(httpc.StatusIn(http.StatusCreated)).
		RetryStatus(nonRetryStatuses).
		NotFound(httpc.StatusIn(http.StatusNotFound)).
		DecodeJSON(&data).
		Header("Accept", "application/json").
		Do(ctx)

	return data, err
}

// WidgetDelete Delete a specific widget by ID.
func (c *Client) WidgetDelete(ctx context.Context, id string) error {
	err := c.client.DELETE(fmt.Sprintf("/v1/widgets/%s", id)).
		Success(httpc.StatusIn(http.StatusNoContent)).
		RetryStatus(nonRetryStatuses).
		NotFound(httpc.StatusIn(http.StatusNotFound)).
		Do(ctx)

	return err
}

// WidgetDownload Downloads a file.
func (c *Client) WidgetDownload(ctx context.Context, id string) (*http.Response, error) {
	resp, err := c.client.GET(fmt.Sprintf("/v1/widgets/%s/download", id)).
		Success(httpc.StatusIn(http.StatusOK)).
		RetryStatus(nonRetryStatuses).
		NotFound(httpc.StatusIn(http.StatusNotFound)).
		DoAndGetReader(ctx)

	return resp, err
}

// WidgetGet Get a specific widget by ID. This is a really, really, really long comment to test out the
// wrapping of comments on descriptions.
func (c *Client) WidgetGet(ctx context.Context, id string, num int64) (Widget, error) {
	errorMap := map[int]error{
		http.StatusUnprocessableEntity: &ErrorResponse{},
		http.StatusInternalServerError: &ErrorResponse{},
	}

	var data Widget
	err := c.client.GET(fmt.Sprintf("/v1/widgets/%s/%d", id, num)).
		Success(httpc.StatusIn(http.StatusOK)).
		RetryStatus(nonRetryStatuses).
		NotFound(httpc.StatusIn(http.StatusNotFound)).
		DecodeJSON(&data).
		Header("Accept", "application/json").
		OnError(errorHandler(errorMap)).
		Do(ctx)

	if cErr := errors.Unwrap(err); cErr != nil && cErr != httpcerrors.ErrUnexpectedResponse {
		err = cErr
	}

	return data, err
}

// WidgetsList Gets a list of all widgets
func (c *Client) WidgetsList(ctx context.Context, qp WidgetsListParams) (WidgetsListResponse, error) {
	var data WidgetsListResponse
	err := c.client.GET("/v1/widgets").
		QueryParams(qp.get()...).
		Success(httpc.StatusIn(http.StatusOK)).
		RetryStatus(nonRetryStatuses).
		NotFound(httpc.StatusIn(http.StatusNotFound)).
		DecodeJSON(&data).
		Header("Accept", "application/json").
		Do(ctx)

	return data, err
}

// WidgetsListStar Gets a list of widgets
func (c *Client) WidgetsListStar(ctx context.Context, qp1 string) (WidgetsListResponse, error) {
	var data WidgetsListResponse
	err := c.client.GET(fmt.Sprintf("/v1/widgets/teststar/%s", qp1)).
		Success(httpc.StatusIn(http.StatusOK)).
		RetryStatus(nonRetryStatuses).
		NotFound(httpc.StatusIn(http.StatusNotFound)).
		DecodeJSON(&data).
		Header("Accept", "application/json").
		Do(ctx)

	return data, err
}

func errorHandler(errMap map[int]error) httpc.ErrorFn {
	return func(r io.Reader, status int) error {
		if data, ok := errMap[status]; ok {
			dec := json.NewDecoder(r)
			if err := dec.Decode(data); err != nil {
				// the server returned a response body we cannot read. Ensure we read the
				// entire response body so the httpc error handling can pick it up, then
				// return nil.
				_, _ = io.Copy(io.Discard, r)
				return nil
			}
			return data
		}

		// In order for the plumbing to work to capture the resp body in the httpc
		// error handling, we need to read the body.
		_, _ = io.Copy(io.Discard, r)
		// by returning nil here, we should fall through to the default handling and
		// send a ClientErr
		return nil
	}
}
