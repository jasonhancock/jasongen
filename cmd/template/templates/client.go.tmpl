// Code generated by {{.GeneratorInfo.Name }}. DO NOT EDIT.
// {{ .GeneratorInfo.Name }} {{ .GeneratorInfo.Version }}

package {{ .PackageName }}

import (
	"context"
    "net/http"
    "net/url"

    "github.com/jasonhancock/go-backoff"
    "github.com/ns-jsattler/go-httpc"
)

var nonRetryStatuses = httpc.StatusNotIn(
    http.StatusUnauthorized,
    http.StatusForbidden,
    http.StatusUnprocessableEntity,
    http.StatusBadRequest,
)

type Client struct {
    client *httpc.Client
}

// New creates a new client that will communicate with the server over HTTP.
func New(host url.URL, client httpc.Doer, b backoff.Backoffer) *Client {
    return &Client{
        client: httpc.New(
            client,
            httpc.WithBaseURL(host.String()),
            httpc.WithBackoff(b),
            httpc.WithRetryResponseErrors(),
        ),
    }
}

{{ range .Handlers }}
// {{ .ExportedName }} {{ .Description }}
func (c *Client) {{ .ExportedName }}({{ .TypeList}} ) {{ if .ResponseType }}({{ .ResponseType }}, {{end}}error{{ if .ResponseType }}){{end}} {
{{- if .ResponseType }}
	var data {{ .ResponseType }}
{{- end }}
    err := c.client.{{ upper .Method }}({{ .ParameterizedURI }}).
{{- if .RequestBodyType }}
		ContentType("application/json").
		Body(req).
{{- end }}
        Success(httpc.StatusIn({{ .SuccessStatusCode }})).
        RetryStatus(nonRetryStatuses).
{{ if .ResponseType }}
        DecodeJSON(&data).
{{ if .SuccessContentType }}
		Header("Accept", {{ .SuccessContentType | quote }}).
{{ end }}
{{ end }}
        Do(ctx)

	return {{ if .ResponseType }}data, {{ end }} err
}
{{ end }}
