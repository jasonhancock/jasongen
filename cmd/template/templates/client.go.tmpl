// Code generated by {{.GeneratorInfo.Name }}. DO NOT EDIT.
// {{ .GeneratorInfo.Name }} {{ .GeneratorInfo.Version }}

package {{ .PackageName }}

import (
	"context"
	"io"
	"encoding/json"
    "net/http"
    "net/url"

    "github.com/jasonhancock/go-backoff"
    "github.com/ns-jsattler/go-httpc"
	httpcerrors "github.com/ns-jsattler/go-httpc/errors"
)

var nonRetryStatuses = httpc.StatusNotIn(
    http.StatusUnauthorized,
    http.StatusForbidden,
    http.StatusUnprocessableEntity,
    http.StatusBadRequest,
)

type Client struct {
    client *httpc.Client
}

type Iface interface {
{{ range .Handlers -}}
{{ .ExportedName }}({{ .TypeList $.Language}} ) {{ if .IsFileDownload }}(*http.Response,{{ else }}{{ if .ResponseType }}({{ .ResponseType }}, {{end}}{{end}}error{{ if .ResponseType }}){{end}}
{{ end }}
}

// New creates a new client that will communicate with the server over HTTP.
func New(host url.URL, client httpc.Doer, b backoff.Backoffer) *Client {
    return &Client{
        client: httpc.New(
            client,
            httpc.WithBaseURL(host.String()),
            httpc.WithBackoff(b),
            httpc.WithRetryResponseErrors(),
        ),
    }
}

{{ range .Handlers }}
{{ printf "%s %s" .ExportedName .Description | formatComment }}
func (c *Client) {{ .ExportedName }}({{ .TypeList $.Language}} ) {{ if .IsFileDownload }}(*http.Response,{{ else }}{{ if .ResponseType }}({{ .ResponseType }}, {{end}}{{end}}error{{ if .ResponseType }}){{end}} {
{{- if .ErrorResponseTypes }}
	errorMap := map[int]error{
{{- range .ErrorResponseTypes }}
{{ httpstatus .Code }}: &{{ .Type }}{},
{{- end }}
	}

{{ end }}

{{- if and (not .IsFileDownload) .ResponseType }}
	var data {{ .ResponseType }}
{{- end }}
    {{ if .IsFileDownload }}resp, {{end}}err := c.client.{{ upper .Method }}({{ .ParameterizedURI }}).
{{- if .RequestBodyType }}
		ContentType("application/json").
		Body(req).
{{- end }}
{{- if .Params.HasQueryParams }}
        QueryParams(qp.get()...).
{{- end }}
{{- if .Params.HasHeaderParams }}
        Headers(qp.getHeaders()...).
{{- end }}
        Success(httpc.StatusIn({{ .SuccessStatusCode }})).
        RetryStatus(nonRetryStatuses).
		NotFound(httpc.StatusIn(http.StatusNotFound)).
{{ if and (not .IsFileDownload) .ResponseType }}
{{ if eq "text/plain" .SuccessContentType }}
		Decode(func(r io.Reader) error {
			var err error
			data, err = io.ReadAll(r)
			return err
		}).
{{ else }}
        DecodeJSON(&data).
{{ end }}
{{ if .SuccessContentType }}
		Header("Accept", {{ .SuccessContentType | quote }}).
{{ end }}
{{ end }}
{{- if .ErrorResponseTypes }}
		OnError(errorHandler(errorMap)).
{{- end }}
{{ if .IsFileDownload -}}
		DoAndGetReader(ctx)
{{ else -}}
		Do(ctx)
{{ end -}}

{{- if .ErrorResponseTypes }}

	if cErr := errors.Unwrap(err); cErr != nil && cErr != httpcerrors.ErrUnexpectedResponse {
		err = cErr
	}

{{- end }}

{{ if .IsFileDownload }}
	return resp, err
{{ else -}}
	return {{ if .ResponseType }}data, {{ end }} err
{{ end -}}
}
{{ end }}

func errorHandler(errMap map[int]error) httpc.ErrorFn {
	return func(r io.Reader, status int) error {
		if data, ok := errMap[status]; ok {
			dec := json.NewDecoder(r)
			if err := dec.Decode(data); err != nil {
				// the server returned a response body we cannot read. Ensure we read the
				// entire response body so the httpc error handling can pick it up, then
				// return nil.
				_, _ = io.Copy(io.Discard, r)
				return nil
			}
			return data
		}

		// In order for the plumbing to work to capture the resp body in the httpc
		// error handling, we need to read the body.
		_, _ = io.Copy(io.Discard, r)
		// by returning nil here, we should fall through to the default handling and
		// send a ClientErr
		return nil
	}
}
