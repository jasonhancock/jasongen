// Code generated by {{.GeneratorInfo.Name }}. DO NOT EDIT.
// {{ .GeneratorInfo.Name }} {{ .GeneratorInfo.Version }}

package {{ .PackageName }}

import (
	"context"
	"net/http"

	"github.com/go-chi/chi/v5"
	"github.com/jasonhancock/recipedb/internal/api"
	"github.com/jasonhancock/recipedb/internal/server"
	"github.com/justinas/alice"
)

// SVC is the interface required of the service.
type SVC interface {
{{- range .Handlers }}
	{{ .Name }}({{ .TypeList }}) {{ if .ResponseType }}({{ .ResponseType }}, {{end}}error{{ if .ResponseType}}){{end}}
{{- end }}
}

// HTTPServer is the transport layer for the service.
type HTTPServer struct {
	svc     SVC
	router  chi.Router
	respond *api.Responder
}

// NewHTTPServer constructs a new HTTPServer.
func NewHTTPServer(svc SVC, checker alice.Constructor, opts ...server.OptFn) *HTTPServer {
	o := server.Option{Router: chi.NewMux()}
	for _, optFn := range opts {
		o = optFn(o)
	}

	s := &HTTPServer{
		svc:     svc,
		respond: o.Responder,
		router:  o.Router,
	}

	rwChecker := alice.New()
	if checker != nil {
		rwChecker.Append(checker)
	}

{{ range .Routes }}
	{{ .GetRoute }}
{{- end }}

	return s
}

// ServeHTTP fulfills the http.Handler interface and allows to use the HTTPServer type in a handler call.
func (s *HTTPServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	s.router.ServeHTTP(w, r)
}

{{ range .Handlers }}
func (s *HTTPServer) {{ .Name }}(w http.ResponseWriter, r *http.Request) {
{{- if .RequestBodyType -}}
        var req {{ .RequestBodyType }}
        if err := api.Decode(r, &req); err != nil {
                s.respond.Err(w, r, err)
                return
        }

{{ end }}
	{{ if .ResponseType}}resp, {{ end }}err := s.svc.{{ .Name }}({{ .ValueList }})
	if err != nil {
		s.respond.Err(w, r, err)
		return
	}

	s.respond.With(w, r, {{ .SuccessStatusCode }}, {{ if .ResponseType }}resp{{ else }}nil{{ end}})
}
{{end}}
