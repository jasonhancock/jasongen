// Code generated by {{.GeneratorInfo.Name }}. DO NOT EDIT.
// {{ .GeneratorInfo.Name }} {{ .GeneratorInfo.Version }}

package {{ .PackageName }}

import (
	"context"
	"net/http"

	"github.com/go-chi/chi/v5"
	"github.com/jasonhancock/go-api"
	"github.com/justinas/alice"
{{ if .PkgModels }}
	models "{{ .PkgModels }}"
{{ end }}
)

// Responder is responsible for sending requests to the client.
type Responder interface {
	With(w http.ResponseWriter, req *http.Request, status int, data any)
	Err(w http.ResponseWriter, req *http.Request, err error)
}

{{ if .HasFileDownloads }}
// FileDownloadResponse is the response from the SVC for downloading a file.
type FileDownloadResponse struct {
	Content     io.ReadCloser
	ContentType string

	// Filename should be the name of the file (if being downloaded). It should be
	// the basename of the file.
	Filename string

	// Download specifies whether or not to instruct the browser to open up the save
	// dialog for the user to download the file.
	Download bool

	// ContentLength describes the length of the content, if known. If not set, a
	// Content-Length header will not be returned in the response.
	ContentLength *uint64
}
{{ end }}

// SVC is the interface required of the service.
type SVC interface {
{{- range .Handlers }}
	{{ .ExportedName }}({{ .TypeList }}) {{ if .IsFileDownload }} (*FileDownloadResponse, {{ else }} {{ if .ResponseType }}({{ models .ResponseType }}, {{end}}{{end}}error{{ if .ResponseType}}){{end}}
{{- end }}
	SVCCustomizations
}

{{ range .Security }}
type {{ typename .Name }} interface {
	Authorized({{.AuthzArgs}}) func(next http.Handler) http.Handler
}
{{- end }}

// HTTPServer is the transport layer for the service.
type HTTPServer struct {
	svc     SVC
	router  chi.Router
	respond Responder
}

// NewHTTPServer constructs a new HTTPServer.
func NewHTTPServer(svc SVC, r Responder, rt chi.Router{{ if .Security }}, {{ .SecurityArgs }}{{ end }}) *HTTPServer {
	s := &HTTPServer{
		svc:     svc,
		respond: r,
		router:  rt,
	}
{{ range $_, $v := .Security }}
{{ range $permIdx, $perm := .ArgPermutations -}}
	{{ argname $v.Name }}AuthzPerm{{ $permIdx }} := alice.New()
{{ end -}}
	if {{ argname $v.Name }} != nil {
{{ range $permIdx, $perm := .ArgPermutations -}}
		{{ argname $v.Name}}AuthzPerm{{ $permIdx }} = {{ argname $v.Name}}AuthzPerm{{ $permIdx }}.Append({{ argname $v.Name }}.Authorized({{ $perm.ArgStr }}))
{{ end -}}
	}
{{ end }}

{{ range .Routes }}
	{{ .GetRoute }}
{{- end }}

	return s
}

// ServeHTTP fulfills the http.Handler interface.
func (s *HTTPServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	s.router.ServeHTTP(w, r)
}

{{ range .Handlers }}
func (s *HTTPServer) {{ .Name }}(w http.ResponseWriter, r *http.Request) {
{{- if .RequestBodyType -}}
        var req {{ models .RequestBodyType }}
        if err := api.Decode(r, &req); err != nil {
                s.respond.Err(w, r, err)
                return
        }
{{ end -}}
{{- range .Params }}
{{- if eq .Location "path" }}
{{- .PathAssignment }}
{{- end }}
{{ end -}}
{{- if .Params.HasQuery -}}
	qp, err := get{{ typename .Name }}Parms(r.URL.Query())
	if err != nil {
		s.respond.Err(w, r, err)
		return
	}

{{- end }}
	{{ if .ResponseType}}resp, {{ end }}err := s.svc.{{ .ExportedName }}({{ .ValueList true }})
	if err != nil {
		s.respond.Err(w, r, err)
		return
	}
{{ if .IsFileDownload }}
	defer resp.Content.Close()

    w.Header().Set("Content-Type", resp.ContentType)
    if resp.Download {
        w.Header().Set("Content-Disposition", "attachment; filename=" + resp.Filename)
    }
    if resp.ContentLength != nil {
	w.Header().Set("Content-Length", fmt.Sprintf("%d", resp.ContentLength))
    }

    w.WriteHeader({{ .SuccessStatusCode }})
    // TODO: probably need to log this error somewhere/how, or add ServeFile capability to the api.Responder?
    _, _ = io.Copy(w, resp.Content)
{{ else -}}
{{ if eq .ResponseType "[]byte" }}
    w.Header().Set("Content-Type", resp.ContentType)
	w.Header().Set("Content-Length", fmt.Sprintf("%d", len(resp)))
    w.WriteHeader({{ .SuccessStatusCode }})
	w.Write(resp)
{{ else -}}
	s.respond.With(w, r, {{ .SuccessStatusCode }}, {{ if .ResponseType }}resp{{ else }}nil{{ end}})
{{ end -}}
{{ end -}}
}
{{end}}
